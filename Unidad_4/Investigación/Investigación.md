## Investigaci√≥n

### Actividad 1

1. **Entiende la aplicaci√≥n**: comienza explorando detenidamente c√≥mo funciona el programa. Usa un un modelo del lenguaje como ChatGPT y el depurador para que verifiques las explicaciones que te propone ChatGPT. Puedes escribir el prompt: quiere entender de manera muy detallada el siguiente programa escrito en C++ y el openframeworks. Luego le das el c√≥digo. Ve preguntando lo que no entiendas. recuerda ir usando al mismo tiempo el depurador de visual studio.

R// 

```c++
class Node {
public:
    float x, y;
    Node* next;

    Node(float _x, float _y);
    ~Node();
};
```

Se define la clase nodo, el puntero (Node*) contiene la posici√≥n, los nodos individuales en est√° clase se convierten en listas enlazadas. Por ultimo se encuentra el destructor.



```c++
class LinkedList {
private:
    Node* head;
    Node* tail;
    int size;

public:
    LinkedList();
    ~LinkedList();
    void addNode(float x, float y);
    void update(float x, float y);
    void display();
    void clear();
};
```
**Private:**
 Head y tail tienen acceso inmediato al inicio y final de la lista, es decir, head tiene acceso inmediato al inicio, si no estuviera el Tail, se deberan recorrer todos los nodos iniciando en Head. Size mantiene el conteo de nodos creados.

**Public:**
Dentro se encuentra el constructor de la lista **LinkedList** inicializando head, tail y el conteo de size. **~LinkedList** es el destructor, encargado de liberar la memoria y evitar fugas, **Update** recorre la lista actualizando la posici√≥n de los nodos anteriores. **display** dibuja los nodos recorriendo la lista de los nodos. **clear** recorre desde *Head* liberando cada nodo con el *delete* y reinicia sus valores.







**ubicaciones de memoria de las listas:**+		

![Head](image.png)

- head	0x0000000000000000 <NULL>	Node *

![Tail](image-1.png)

- tail	0x0000000000000000 <NULL>	Node *

Se puede observar que ambos est√°n apuntando al Nullprint, lo que significa **La lista esta vacia**

![Current](image-2.png)

- Es un puntero a un nodo (Node*).
- Apunta a la direcci√≥n de memoria 0x000000000014f7c8


![Head_values](image-3.png)

- Es un puntero al primer nodo de la lista.
- Apunta a la direcci√≥n 0x000000000352aae0, que contiene un nodo v√°lido.
- x=512.000000, y=384.000000 Son las coordenadas del primer nodo.











2. **Realiza evaluaciones formativas**. Dile a ChatGPT que te genere preguntas para verificar si entiendes c√≥mo funciona el programa. Trata de verificar tus hip√≥tesis usando el depurador y luego con las conclusiones del experimento responde la pregunta de ChatGPT. Contin√∫a con este proceso hasta que est√©s seguro de que entiendes c√≥mo funciona el programa.

R// 1. ¬øQu√© condiciones indican que un nodo est√° correctamente encadenado en la lista?
Selecciona todas las que apliquen:
- [ ] Su puntero next es distinto de nullptr.
- [ ] Su direcci√≥n de memoria es igual a la de head.
- [ ] Su puntero next apunta a una direcci√≥n v√°lida.
- [ ] Su valor x es mayor que cero.
üí° Usa inspecci√≥n r√°pida para verificar si next apunta a otro nodo v√°lido.


2. ¬øQu√© efectos observas al ejecutar clear() en la lista?
Selecciona todas las que apliquen:
- [ ] head y tail se vuelven nullptr.
- [ ] Todos los nodos se eliminan de memoria.
- [ ] El valor de size se reinicia a 0.
- [ ] Se dibujan los nodos en pantalla como c√≠rculos negros.
üí° Coloca un breakpoint en clear() y observa los cambios en head, tail, y size.


3. ¬øQu√© valores esperas ver en el depurador si la lista est√° vac√≠a?
Selecciona todas las que apliquen:
- [ ] head == nullptr
- [ ] tail == nullptr
- [ ] size == 0
- [ ] head->next apunta a tail
üí° Verifica esto justo despu√©s de presionar la tecla 'c' que llama a clear().


4. ¬øQu√© observas en los nodos cuando se llama a update()?
Selecciona todas las que apliquen:
- [ ] El primer nodo toma la posici√≥n del mouse.
- [ ] Cada nodo copia la posici√≥n del nodo anterior.
- [ ] El √∫ltimo nodo mantiene su posici√≥n original.
- [ ] Todos los nodos se eliminan.
üí° Coloca un breakpoint en update() y observa c√≥mo cambian x e y en cada nodo.


5. ¬øQu√© condiciones indican que un nodo es el √∫ltimo en la lista?
Selecciona todas las que apliquen:
- [ ] Su puntero next es nullptr.
- [ ] Su direcci√≥n de memoria coincide con tail.
- [ ] Su valor x es igual al del nodo anterior.
- [ ] Su puntero next apunta a head.

**Respuestas** 

1.) C
2.) C
3.) A
4.) B
5.) A


‚úÖ 1.) ¬øQu√© indica que un nodo est√° correctamente encadenado?
Tu respuesta: C ‚Üí ‚ÄúQue su puntero next apunta a otro nodo v√°lido‚Äù
‚úî Correcto.
- En el depurador, si inspeccionas head->next y ves una direcci√≥n v√°lida (no nullptr), el nodo est√° encadenado.
- Esto es lo que define la estructura de una lista enlazada.

‚úÖ 2.) ¬øQu√© sucede cuando se llama a clear()?
Tu respuesta: C ‚Üí ‚ÄúSe eliminan todos los nodos y se reinicia la lista‚Äù
‚úî Correcto.
- En el depurador, despu√©s de ejecutar clear(), head y tail se vuelven nullptr, y size se reinicia a 0.
- Puedes verificar que los nodos ya no existen en memoria.

‚úÖ 3.) ¬øQu√© valor esperas ver si la lista est√° vac√≠a?
Tu respuesta: A ‚Üí ‚Äúhead == nullptr‚Äù
‚úî Correcto.
- Aunque la opci√≥n ideal ser√≠a ‚Äúhead y tail son nullptr‚Äù, tu respuesta es t√©cnicamente v√°lida.
- En el depurador, si head == nullptr, no hay nodos activos.

‚úÖ 4.) ¬øQu√© observas en los nodos cuando se llama a update()?
Tu respuesta: B ‚Üí ‚ÄúCada nodo copia la posici√≥n del nodo anterior‚Äù
‚úî Correcto.
- En el c√≥digo, update() propaga la posici√≥n del mouse desde head hacia los dem√°s nodos.
- Puedes ver c√≥mo x e y cambian en cascada en el depurador.

‚úÖ 5.) ¬øQu√© indica que un nodo es el √∫ltimo en la lista?
Tu respuesta: A ‚Üí ‚ÄúSu puntero next es nullptr‚Äù
‚úî Correcto.
- En el depurador, si inspeccionas tail->next y ves nullptr, ese nodo es el √∫ltimo.
- Esto es una propiedad estructural de las listas enlazadas simples.

üß† Conclusi√≥n
Tu razonamiento est√° alineado con el comportamiento real del programa y con lo que se puede verificar en el depurador. Has demostrado comprensi√≥n estructural, sem√°ntica y de ciclo de vida de los nodos.



3. ¬øQu√© es una lista enlazada y en qu√© se diferencia de un arreglo en cuanto a la forma en que los elementos est√°n almacenados en la memoria?

R// Es una estructura de datos **Din√°mica** compuesta de nodos, se guarda la siguiente informaci√≥n: coordenadas en (X,Y) y un puntero que apunta al siguiente dodno **next**. 

**Diferencias:**

nodos:
- los nodos pueden estar ubicados en cualquier parte.
- Siguen una secuencia con un puntero *Next
- Se pueden crear en cualquier parte sin importar si al incio o al final.
- Crece o decrece en tiempo real.
- se puede crear con un new o delete
- Se puede eliminar un nodo sin importar su posici√≥n.


Arreglos: 

- Los dato se guardan en fila.
- Se guardan poniendo el indice del array.
- Su creaci√≥n es fija si no se coloca un vector. 
- es est√°tico.



4. Al observar el c√≥digo de una lista enlazada en C++, ¬øC√≥mo crees que se vinculan los nodos entre s√≠? ¬øQu√© estructura se utiliza para lograr esta conexi√≥n?

R// los nodos se crean mediante un puntero, en este ejercicio el puntero es *Next, este nodo se encarga de revisar secuencialmente los nodos formando una cadena. Cuando la secuencia se acaba apunta a un Null. Parece ser que los nodos saben donde esta el siguiente, pero no saben donde esta el anterior. 

Para ser conectados se debe expresar explicitamente una cabeza y una cola, ademas de crear una lista enlazada. Dentro de la lista se gestiona y se organiza el encadenamiento de los nodos.



5. ¬øC√≥mo se gestiona la memoria en una lista enlazada? Investiga c√≥mo se crea y se destruye un nodo en memoria utilizando el operador¬†new¬†y¬†delete¬†en C++.

R// Al momento de agregar un nodo a la lista, se utiliza el operador new para reservar espacio en el heap:

- Esto asigna memoria suficiente para un objeto Node.
- Devuelve un puntero a esa regi√≥n de memoria.
- El nodo permanece activo hasta que se libere expl√≠citamente con delete.

Para eliminar un nodo se llama a una funci√≥n Clear(), se encarga de recorrer la lista y de eliminar cada nodo manualmente:

- delete  libera la memoria ocupada por el nodo.
- Esto devuelve el espacio al sistema operativo.
- Es esencial para evitar fugas de memoria (memory leaks).




6. Considerando la estructura de una lista enlazada, ¬øqu√© ventajas ofrece en comparaci√≥n con un arreglo cuando se trata de insertar o eliminar elementos en posiciones intermedias?

R// 
Lista enlazada
- Cada nodo se almacena en una posici√≥n independiente de memoria.
- Los nodos se conectan mediante punteros (next).
- Inserciones y eliminaciones en cualquier parte son eficientes si tienes el nodo anterior.
- El tama√±o es din√°mico: puedes agregar o quitar nodos sin redimensionar.
- El acceso es secuencial: debes recorrer desde el inicio para llegar a un nodo espec√≠fico.
- Puede haber fragmentaci√≥n en memoria, ya que los nodos est√°n dispersos.
- Requiere gesti√≥n manual de memoria con new y delete.

 Arreglo
- Todos los elementos est√°n en posiciones contiguas de memoria.
- No hay punteros entre elementos; se accede por √≠ndice.
- Inserciones y eliminaciones intermedias requieren mover elementos (costosas).
- El tama√±o es fijo al momento de creaci√≥n (a menos que uses estructuras din√°micas como std::vector).
- El acceso es directo: puedes ir al elemento i en tiempo constante.
- No hay fragmentaci√≥n: todo est√° en un bloque continuo.
- La gesti√≥n de memoria puede ser autom√°tica (si es est√°tico) o controlada (si usas new[]).



7. En el c√≥digo presentado, ¬øC√≥mo se asegura que no haya fugas de memoria? ¬øQu√© papel juega el destructor en la clase¬†LinkedList?

R// La gesti√≥n de memoria se encuentra en la clase LinkedList(), el destructor de LinkedList se asegura de recorrer toda la lista y eliminar cada nodo antes de que el objeto sea destruido.

```c++
~LinkedList() {
    clear();


```
dentro de clear() ocurre lo siguiente:
- Se recorre la lista desde head.
- En cada iteraci√≥n, se guarda el nodo actual, se avanza al siguiente, y se elimina el nodo guardado con delete.
- Al final, se reinician head, tail y size para dejar la lista en estado limpio.
Este patr√≥n garantiza que cada nodo creado con new sea destruido con delete, cumpliendo con la regla fundamental de gesti√≥n de memoria en C++: cada new debe tener un delete.



8. ¬øQu√© sucede en la memoria cuando se invoca el m√©todo¬†clear()¬†en una lista enlazada? Explica paso a paso c√≥mo se liberan los recursos.

R// 1. Inicio del recorrido
- Se declara un puntero auxiliar, por ejemplo current, que apunta al primer nodo (head).
- Este puntero se usar√° para recorrer la lista sin perder la referencia a los nodos.

2. Iteraci√≥n nodo por nodo
- Mientras current no sea nullptr, se hace lo siguiente:
- Se guarda el nodo actual en un puntero temporal (temp).
- Se avanza current al siguiente nodo (current = current->next).
- Se elimina el nodo guardado con delete.
Esto libera la memoria ocupada por ese nodo en el heap. El sistema operativo recupera ese bloque.

3. Actualizaci√≥n de punteros
- Una vez que todos los nodos han sido eliminados:
- head se establece en nullptr.
- tail tambi√©n se establece en nullptr.
- size se reinicia a 0.
Esto deja la lista en estado limpio, sin referencias a memoria din√°mica.


 ¬øQu√© sucede en el heap?
- Cada nodo creado con new tiene una direcci√≥n √∫nica en el heap.
- Al eliminarlo con delete, esa direcci√≥n se libera.
- Si no se ejecutara delete, esos bloques quedar√≠an ocupados, generando fugas de memoria.



9. Explica c√≥mo cambia la estructura en memoria de una lista enlazada al agregar un nuevo nodo al final de la lista. ¬øC√≥mo afecta esto al rendimiento de la lista enlazada?

R// Los cambios ocurridos dentro del programa se evidencian de la siguiente forma, con el new se reserva un bloque de momemoria en el heap, siendo independiente de los demas nodos. Luego se actualiza el puntero *next que antes miraba a la cola, pasando a ver el nuevo nodo. Este ultimo nodo pasa a ser el ultimo de la lista. La variable size aumenta su contador.

Ventaja: 

- No necesita recorrer toda la lista para insertar el nuevo nodo en la nueva ubicaci√≥n, unicamente agrega el nuevo nodo y actualiza el puntero y el tail. No hay reubicaci√≥n de datos de memoria, ni copia de bloques de memoria y tampoco se desplazan los datos. 

Desventajas: 

- La busqueda de la ubicaci√≥n es lenta, debe empezar desde el head hasta llegar donde quiere agregar el nuevo nodo.
- Se debe crear con un new, lo que significa que usa espacios de memoria en el heap 
- Si no se libera el nodo puede causar figas de memoria.



10. Analiza una situaci√≥n en la que utilizar una lista enlazada ser√≠a m√°s ventajoso que utilizar un arreglo. Justifica tu respuesta considerando la gesti√≥n de memoria y las operaciones de inserci√≥n y eliminaci√≥n.

R// Un puede ser el historial de busqueda, es un buen ejemplo porque se puede navegar entre nodos, que serian los sitios web y eliman los nodos seria eliminar la referencia. Usando la lista enlazada es m√°s sencillo ingresar una nueva referencia sin tener que desplazar alguna otra referencia como ocurrir√≠a con un arreglo. Para eliminar solo se libera ese espacio de memoria sin tener que compactar el conjunto y permite la eliminaci√≥n especifica sin tener que recorrer toda la lista. 


11. Despu√©s de estudiar el manejo de memoria en listas enlazadas, ¬øC√≥mo aplicar√≠as este conocimiento para dise√±ar una estructura de datos personalizada para una aplicaci√≥n creativa? ¬øQu√© aspectos considerar√≠as para asegurar la eficiencia y evitar fugas de memoria?

R// 



12. Reflexiona sobre las diferencias en la gesti√≥n de memoria entre C++ y un lenguaje con recolecci√≥n de basura autom√°tica como C#. ¬øQu√© ventajas y desaf√≠os encuentras en la gesti√≥n expl√≠cita de memoria en C++ al trabajar con estructuras de datos?


13. Imagina que est√°s optimizando una pieza de arte generativo que usa listas enlazadas para representar elementos en movimiento. ¬øQu√© consideraciones tomar√≠as en cuenta para garantizar que la gesti√≥n de la memoria sea eficiente y que no ocurran fugas de memoria?


14. **Pruebas:**¬†pregunta a ChatGPT c√≥mo podr√≠as probar las partes del programa y el programa completo. Luego realiza las pruebas y verifica si los resultados coinciden con tus expectativas.

### Actvidad 2

1. **Entendiendo la aplicaci√≥n**: comienza explorando detenidamente c√≥mo funciona el programa. Usa un un modelo del lenguaje como ChatGPT y el depurador para que verifiques las explicaciones que te propone ChatGPT. Puedes escribir el prompt: quiere entender de manera muy detallada el siguiente programa escrito en C++ y el openframeworks. Luego le das el c√≥digo. Ve preguntando lo que no entiendas. recuerda ir usando al mismo tiempo el depurador de visual studio.

**Clase Nodo**: 	Cada  representa un c√≠rculo en pantalla.


‚Ä¢ 	 guarda las coordenadas (en el heap).


‚Ä¢ 	 apunta al siguiente nodo en la pila (estructura tipo lista enlazada).


‚Ä¢ 	Se construye din√°micamente con , lo que implica gesti√≥n manual de memoria.

**Clase Stack**: 
- Crea un nuevo nodo en el heap.


- Lo enlaza al nodo anterior (top).


- Actualiza top para que apunte al nuevo nodo.


üß† Esto es una inserci√≥n en cabeza, t√≠pica de una pila LIFO.


```c++
void pop() {
    if (top != nullptr) {
        Node* temp = top;
        top = top->next;
        delete temp;  // Liberar memoria del nodo eliminado
    }
}
```

- Elimina el nodo superior.
- Libera su memoria con delete.
- Actualiza top al siguiente nodo.
üîç Aqu√≠ se observa claramente la transici√≥n de punteros y liberaci√≥n de memoria.

```c++
void clear() {
    while (top != nullptr) {
        pop();
    }
}
```

- Elimina todos los nodos de la pila.

- Muy √∫til para evitar fugas de memoria al cerrar la app.



```c++
void clear() {
    while (top != nullptr) {
        pop();
    }
}

```






2. **Realiza evaluaciones formativas**. Dile a ChatGPT que te genere preguntas para verificar si entiendes c√≥mo funciona el programa. Trata de verificar tus hip√≥tesis usando el depurador y luego con las conclusiones del experimento responde la pregunta de ChatGPT. Contin√∫a con este proceso hasta que est√©s seguro de que entiendes c√≥mo funciona el programa.



3. **Pruebas:**¬†pregunta a ChatGPT c√≥mo podr√≠as probar las partes del programa y el programa completo. Luego realiza las pruebas y verifica si los resultados coinciden con tus expectativas.

Preguntas de reflexi√≥n para el stack:

1. ¬øC√≥mo se gestiona la memoria en una implementaci√≥n manual de un stack en C++? Reflexiona sobre c√≥mo el uso de¬†new¬†y¬†delete¬†en la creaci√≥n y destrucci√≥n de nodos afecta el rendimiento y la seguridad de tu programa.



2. ¬øPor qu√© es importante liberar la memoria cuando se desapila un nodo en un stack? Considera las consecuencias de no liberar memoria en t√©rminos de fugas de memoria y c√≥mo esto puede impactar aplicaciones de largo tiempo de ejecuci√≥n.



3. ¬øQu√© diferencias existen entre usar un stack de la STL (std::stack) y crear un stack manualmente? Explora c√≥mo la abstracci√≥n que proporciona la STL puede simplificar la implementaci√≥n, pero tambi√©n c√≥mo una implementaci√≥n manual ofrece mayor control sobre la gesti√≥n de recursos.



4. ¬øC√≥mo afecta la estructura de un stack al orden de acceso y eliminaci√≥n de elementos? Analiza c√≥mo la naturaleza LIFO (Last In, First Out) del stack influye en los tipos de problemas que esta estructura de datos puede resolver eficientemente.



5. ¬øC√≥mo podr√≠as modificar el stack para almacenar tipos de datos m√°s complejos (e.g., objetos con m√∫ltiples atributos) sin causar problemas de memoria? Reflexiona sobre c√≥mo gestionar adecuadamente la memoria para objetos m√°s complejos y c√≥mo esto afectar√≠a tu implementaci√≥n actual.

Preguntas de autoevaluaci√≥n:

1. ¬øPuedo explicar detalladamente c√≥mo funciona el proceso de apilar y desapilar nodos en un stack, incluyendo la gesti√≥n de memoria?


2. ¬øSoy capaz de identificar y corregir una fuga de memoria en una implementaci√≥n de stack manual?


3. ¬øPuedo modificar el stack para que incluya una funci√≥n que busque un elemento espec√≠fico, sin alterar el orden de los elementos apilados?


4. ¬øEntiendo c√≥mo la estructura LIFO del stack afecta el flujo de datos y puedo dar ejemplos de problemas que se resuelvan mejor con un stack?


5. ¬øPuedo implementar y depurar un stack para tipos de datos m√°s complejos, asegur√°ndome de que no haya fugas de memoria ni errores de puntero?

Preguntas de reflexi√≥n para la queue:

1. ¬øC√≥mo se maneja la memoria en una implementaci√≥n manual de una queue en C++? Reflexiona sobre c√≥mo se gestionan los nodos al encolar y desencolar elementos y las implicaciones en t√©rminos de eficiencia y seguridad.


2. ¬øQu√© desaf√≠os espec√≠ficos presenta la implementaci√≥n de una queue en comparaci√≥n con un stack en t√©rminos de gesti√≥n de memoria? Considera las diferencias en el manejo de punteros¬†front¬†y¬†rear, y c√≥mo estos afectan el proceso de encolado y desencolado.


3. ¬øC√≥mo afecta la estructura FIFO (First In, First Out) de una queue a su uso en diferentes tipos de problemas? Analiza c√≥mo la estructura FIFO influye en la resoluci√≥n de problemas donde el orden de procesamiento es crucial, como en sistemas de colas de espera.


4. ¬øC√≥mo podr√≠as implementar una queue circular y cu√°l ser√≠a su ventaja respecto a una queue lineal en t√©rminos de uso de memoria? Reflexiona sobre c√≥mo una queue circular puede mejorar la eficiencia en ciertos contextos y qu√© cambios ser√≠an necesarios en la implementaci√≥n.


5. ¬øQu√© problemas podr√≠an surgir si no se gestionan correctamente los punteros¬†front¬†y¬†rear¬†en una queue, y c√≥mo podr√≠as evitarlos? Considera posibles errores como la p√©rdida de referencias a nodos y c√≥mo una gesti√≥n cuidadosa de los punteros puede prevenir estos problemas.

Preguntas de autoevaluaci√≥n:

1. ¬øPuedo explicar claramente el proceso de encolar y desencolar nodos en una queue, incluyendo la gesti√≥n de memoria?


2. ¬øSoy capaz de identificar y corregir problemas relacionados con la gesti√≥n de los punteros¬†front¬†y¬†rear¬†en una queue?


3. ¬øPuedo modificar la queue para implementar una queue circular, entendiendo c√≥mo esto afectar√≠a la gesti√≥n de memoria?


4. ¬øEntiendo c√≥mo la estructura FIFO de una queue afecta el flujo de datos y puedo dar ejemplos de problemas que se resuelvan mejor con una queue?


5. ¬øPuedo implementar y depurar una queue para tipos de datos m√°s complejos, asegur√°ndome de que no haya fugas de memoria ni errores de puntero?